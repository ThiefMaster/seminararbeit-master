\chapter{Flask}
\section{Allgemeines}

Bei Flask\footnote{\href{http://flask.pocoo.org}{http://flask.pocoo.org}} handelt es sich um ein
Python-basiertes Microframework für Webapplikationen. Das \emph{Micro} bedeutet, dass es sich bei
Flask um ein Framework handelt, welches nur die grundlegendsten Funktionen zur Entwicklung einer
Webanwendung zur Verfügung stellt und dem Entwickler somit ein solides Grundgerüst bietet ohne ihm
vorzugeben, welche Datenbank bzw. welche Datenbankabstraktion er zu benutzen hat.

Das Framework basiert auf der \emph{WSGI utility library}
Werkzeug\footnote{\href{http://werkzeug.pocoo.org}{http://werkzeug.pocoo.org}} welche
Lowlevel-Funktionen für das WSGI-Interface, URL-Routing und diverse HTTP-Features wie Header,
Cookies, Weiterleitungen und Formulardaten zur Verfügung stellt. In der Regel kommt man mit diesen
jedoch nicht direkt in Berührung, da Flask eigene APIs für häufig genutzte Funktionen bereitstellt.

\section{Aufbau}

Man kann Flask grob in die folgenden Bereiche aufteilen: \emph{Application}, \emph{Blueprints},
\emph{Routing}, \emph{Sessions}, \emph{Templates} und \emph{Signals}.

Die \emph{Application} ist eine Instanz der \lstinline{Flask}-Klasse und ist das zentrale Objekt der
Webanwendung. Sie implementiert dabei die WSGI-Applikation und alle applikationsspezifischen
Operationen laufen über diese Instanz.

Bei \emph{Blueprints} handelt es sich vereinfacht um Objekte die über eine ähnliche API wie das
\lstinline{Flask}-Objekt verfügen. Sie ermöglichen es, Teile einer Applikation (beispielsweise die
Benutzerverwaltung) wiederverwendbar zu gestalten und mit einem einzigen Funktionsaufruf alle im
\emph{Blueprint} gespeicherten URL-Handler und Templates mit einer konkreten Applikation
(repräsentiert durch eine \lstinline{Flask}-Instanz) zu verknüpfen.

Das \emph{Routing} ist dafür zuständig, URLs der Form \emph{/foo/bar/} mit Python-Funktionen oder
-Klassen zu verknüpfen. Dabei können die einzelnen Pfadelemente auch dynamisch sein, sodass saubere
URLs ermöglicht werden. Beispielsweise könnte die Routendefiniton für einen Artikel in einem
Wiki der String \lstinline{'/wiki/<name>'} sein. In diesem Fall würde die verknüpfte Funktion für
jede mit \emph{/wiki/} beginnende URL ausgeführt werden. Ebenfalls vom Routing-System unterstützt
wird die umgekehrte Richtung, d.h. das Generieren von URLs anhand des Namens der verknüpften
Python-Funktion. Dies erlaubt dem Entwickler, in seinen Templates keinerlei URLs hardcoden zu
müssen. Darüberhinaus wird vermieden, dass URLs mühsam mit Stringoperationen zusammengebaut werden
müssen - stattdessen werden einfach der Funktionsname und die jeweiligen Parameter an die Funktion
\lstinline{url_for()} übergeben.

Die in den meisten Webanwendungen dringend benötigten \emph{Sessions} sind in Flask durch signierte
Cookies realisiert. Dabei handelt es sich um ein Cookies, welche durch eine kryptographische
Signatur vor Manipulationen geschützt sind. Der Benutzer kann daher also den Inhalt der
Sessionvariablen ohne Weiteres auslesen, ist jedoch nicht in der Lage ihn zu verändern. Der
Entwickler kann auf die Session wie auf ein normales Python-\lstinline{dict} zugreifen; sollte die
Signature eines Wertes ungültig sein, wird dieser beim Parsen des Session-Cookies ignoriert und
taucht dementsprechend nicht in der Session auf.

\emph{Templates} sind aus einer modernen Webanwendung kaum wegzudenken. Während früher -
insbesondere zu den Anfangszeiten von PHP und Perl - oftmals HTML-Code direkt in die
Quellcodedateien geschrieben wurde, ist diese Vermischung von Layout/Design und Logik heute
undenkbar und würde sowohl die Lesbarkeit als auch die Wartbarkeit stark senken. Daher integriert
Flask standardmäßig die Templateengine
Jinja2\footnote{\href{http://jinja.pocoo.org}{http://jinja.pocoo.org}}. Dabei handelt es sich um
eine komfortable Templateengine, die Templates \emph{just in time} in Python-Bytecode kompiliert und
dadurch eine hohe Performance bietet. Die Templatesyntax kann angepasst werden um unabhängig vom
Ausgabeformat die Lesbarkeit der Templates zu erhalten - beispielsweise ist die Standardsyntax, die
\lstinline|{% ... %}| und \lstinline|{{ ... }}| nutzt für ein \LaTeX-Dokument nicht zu
gebrauchen.

\emph{Signals} ermöglichen es, Code auszuführen, wenn framework-intern bestimmte Ereignisse
eintreten. Beispielsweise wird das \lstinline{request_tearing_down}-Signal immer dann ausgelöst,
wenn ein HTTP-Request vollständig bearbeitet wurde. Da diese Signal immer ausgelöst wird - auch wenn
eine Exception aufgetreten ist - bietet es sich beispielsweise dazu an, eine Datenbankverbindung zu
schließen oder sonstige Aufräumarbeiten auszuführen.

\section{Extensions}

Da Flask wie zuvor schon erwähnt ein Micro-Framework ist liefert es nur die wichtigsten Module mit.
Allerdings gibt es für so gut wie jeden wichtigen Use-Case eine
Extension\footnote{\href{http://flask.pocoo.org/extensions}{http://flask.pocoo.org/extensions}}. Die
wohl wichtigsten und bekanntesten Extensions sind dabei \emph{Flask-SQLAlchemy} zur Integration des
ORM-Frameworks
\emph{SQLAlchemy}\footnote{\href{http://www.sqlalchemy.org}{http://www.sqlalchemy.org}},
\emph{Flask-Uploads} zur komfortablen Verarbeitung von hochgeladenen Dateien, \emph{Flask-WTF} zur
Integration von
WTForms\footnote{\href{http://wtforms.simplecodes.com}{http://wtforms.simplecodes.com}}, einem
Python-Modul zum deklarativen Erstellen und Validieren von HTML-Formularen, und \emph{Flask-Mail}
zum Verwenden von E-Mails.

Eine weiterer Use-Case für den ebenfalls eine Extension existiert ist der Login von Benutzern.
\emph{Flask-Login} übernimmt dabei den Login/Logout-Prozess, unterstützt die oftmals erwünschte
\enquote{Eingeloggt bleiben}-Funktion beim Login und kann optional mit weiteren Extensions verknüpft
werden sofern ein Rechtesystem benötigt wird, welches über \enquote{User ist eingeloggt} hinausgeht.


\section{Grundgerüst}

\autoref{lst:simple-flask-app} zeigt eine einfache \enquote{Hello World}-Applikation. Mit
\lstinline{Flask(__name__)} wird eine neue Instanz der \lstinline{Flask}-Klasse erstellt; als
Parameter wird der Name des aktuellen Moduls übergeben; er hilft Flask dabei, Pfade zu statischen
Ressourcen korrekt zu bestimmen und im Debugger zu erkennen ob ein Modul vermutlich Teil der
Applikation ist oder nicht. Der Decorator \lstinline{app.route('/')} registriert einen
Routing-Endpoint für den Pfad \emph{/} mit dem Namen der dazugehörigen Funktion, also
\lstinline{index}.

Wenn ein Python-Script direkt, d.h. über \lstinline{python filename.py} auf der Shell, ausgeführt
wird, so ist der \lstinline{__name__} in diesem Script immer \lstinline{'__main__'}. Dieses Feature
von Python wird in einfachen Flask-Anwendungen in der Regel dazu benutzt, den integrierten Webserver
zu starten, sodass die Applikation während der Entwicklung komfortabel ausgeführt und dank des
integrierten Debuggers im Fehlerfall auch debuggt werden kann.

\begin{lstlisting}[caption=Hello World mit Flask,label=lst:simple-flask-app]
from flask import Flask
app = Flask(__name__)

@app.route('/')
def index():
    return 'Hello World!'

if __name__ == '__main__':
    app.run()
\end{lstlisting}
